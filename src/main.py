import cProfile
import logging
import sys
import time

import chainlit as cl
from lingua import LanguageDetector
from llama_index.core.callbacks import CallbackManager
from llama_index.core.chat_engine.types import BaseChatEngine

from callbacks import CustomLlamaIndexCallbackHandler
from citation import postprocess_citation
from lingua_iso_codes import IsoCode639_1
from pipelines import get_pipeline
from translation import (
    BaseTranslator, detect_language, get_language_detector, get_translator, translate,
    translate_lightrag_response, is_lightrag_response
)

# LightRAG integration
from lightrag_integration.component import LightRAGComponent
from lightrag_integration.config.settings import LightRAGConfig

import os
from openai import OpenAI
PERPLEXITY_API = os.environ["PERPLEXITY_API"]
client = OpenAI(api_key=PERPLEXITY_API, base_url="https://api.perplexity.ai")
import requests
import re

logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)
logging.getLogger().addHandler(logging.StreamHandler(stream=sys.stdout))


@cl.password_auth_callback
def auth_callback(username: str, password: str):
    if (username, password) == ("admin", "admin123") or (username, password) == ("testing", "ku9R_3"):
        return cl.User(
            identifier="admin",
            metadata={"role": "admin", "provider": "credentials"}
        )
    else:
        return None


@cl.on_chat_start
async def on_chat_start(accepted: bool = False):
    #callback_manager = CallbackManager([CustomLlamaIndexCallbackHandler()])
    #chat_engine_coroutine = cl.make_async(get_pipeline)(callback_manager=callback_manager)
    #cl.user_session.set("chat_engine_coroutine", chat_engine_coroutine)

    # Initialize LightRAG component
    try:
        lightrag_config = LightRAGConfig.from_env()
        lightrag_component = LightRAGComponent(lightrag_config)
        await lightrag_component.initialize()
        cl.user_session.set("lightrag_component", lightrag_component)
        logging.info("LightRAG component initialized successfully")
    except Exception as e:
        logging.error(f"Failed to initialize LightRAG component: {str(e)}")
        # Continue without LightRAG - will fall back to Perplexity only
        cl.user_session.set("lightrag_component", None)

    # display intro message and disclaimer
    descr = 'Hello! Welcome to the Clinical Metabolomics Oracle'
    subhead = "I'm a chat tool designed to help you stay informed about clinical metabolomics. I can access and understand a large database of scientific publications.\n\nTo learn more, checkout the Readme page."
    disclaimer = 'The Clinical Metabolomics Oracle is an automated question answering tool, and is not intended to replace the advice of a qualified healthcare professional.\nContent generated by the Clinical Metabolomics Oracle is for informational purposes only, and is not advice for the treatment or diagnosis of any condition.'
    elements = [
        cl.Text(name=descr, content=subhead, display='inline'),
        cl.Text(name='Disclaimer', content=disclaimer, display='inline')
    ]
    await cl.Message(
        content = '',
        elements=elements,
        author="CMO",
    ).send()

    res = {}
    # continue prompting until user selects 'I understand'
    while not accepted:
        res = await cl.AskActionMessage(
            content='Do you understand the purpose and limitations of the Clinical Metabolomics Oracle?',
            actions = [
                cl.Action(
                    name='I Understand', 
                    label='I Understand',
                    description='Agree and continue',
                    payload={"response":"agree"}
                    ),
                cl.Action(
                    name='Disagree',
                    label='Disagree', 
                    description='Disagree to terms of service',
                    payload={"response":"disagree"}
                    )
            ],
            timeout = 300,  # five minutes
            author="CMO",
        ).send()

        accepted = res["label"] == "I Understand"

        if not accepted:
            await cl.Message(
                content = "You must agree to the terms of service to continue.",
                author="CMO",
            ).send()

    welcome = "Welcome! Ask me anything about clinical metabolomics, and I'll do my best to find you the most relevant and up-to-date information."

    await cl.Message(
            content=welcome,
            author="CMO",
        ).send()
    translator: BaseTranslator = get_translator()
    cl.user_session.set("translator", translator)
    await set_chat_settings(translator)

    iso_codes = [
        IsoCode639_1[code.upper()].value
        for code in translator.get_supported_languages(as_dict=True).values()
        if code.upper() in IsoCode639_1._member_names_
    ]
    detector = get_language_detector(*iso_codes)
    cl.user_session.set("detector", detector)


@cl.author_rename
def rename(orig_author: str):
    rename_dict = {"Chatbot": "CMO"}
    return rename_dict.get(orig_author, orig_author)


async def set_chat_settings(translator):
    initial_language_value = "Detect language"
    languages_to_iso_codes = translator.get_supported_languages(as_dict=True)
    language_values = [initial_language_value] + [language.title() for language in languages_to_iso_codes.keys()]
    await cl.ChatSettings(
        [
            cl.input_widget.Select(
                id="translator",
                label="Translator",
                values=["Google", "OPUS-MT"],
                initial_value="Google",
            ),
            cl.input_widget.Select(
                id="language",
                label="Language",
                values=language_values,
                initial_value=initial_language_value,
            )
        ]
    ).send()


def chat(chat_engine: BaseChatEngine, content: str, profile: bool = False):
    if profile:
        pr = cProfile.Profile()
        pr.enable()
    response = chat_engine.chat(content)
    if profile:
        pr.disable()
        pr.dump_stats("profile.prof")
    return response


async def query_lightrag(lightrag_component: LightRAGComponent, question: str) -> dict:
    """
    Query LightRAG component and return formatted response.
    
    Args:
        lightrag_component: Initialized LightRAG component
        question: User question
        
    Returns:
        Dictionary with response content and metadata
    """
    try:
        result = await lightrag_component.query(question)
        
        # Format response with citations if available
        content = result["answer"]
        bibliography = ""
        
        if result.get("source_documents"):
            bibliography += "\n\n**Sources:**\n"
            for i, doc in enumerate(result["source_documents"], 1):
                confidence = result.get("confidence_breakdown", {}).get(doc, result.get("confidence_score", 0.0))
                bibliography += f"[{i}]: {doc}\n      (Confidence: {confidence:.2f})\n"
        
        return {
            "content": content,
            "bibliography": bibliography,
            "confidence_score": result.get("confidence_score", 0.0),
            "processing_time": result.get("processing_time", 0.0),
            "source": "LightRAG",
            "metadata": result.get("metadata", {})
        }
        
    except Exception as e:
        logging.error(f"LightRAG query failed: {str(e)}")
        raise


async def query_perplexity(question: str) -> dict:
    """
    Query Perplexity API and return formatted response.
    
    Args:
        question: User question
        
    Returns:
        Dictionary with response content and metadata
    """
    try:
        url = "https://api.perplexity.ai/chat/completions"

        payload = {
            "model": "sonar",
            "messages": [
                {
                    "role": "system",
                    "content": (
                        "You are an expert in clinical metabolomics. You respond to"
                        "user queries in a helpful manner, with a focus on correct"
                        "scientific detail. Include peer-reviewed sources for all claims."
                        "For each source/claim, provide a confidence score from 0.0-1.0, formatted as (confidence score: X.X)"
                        "Respond in a single paragraph, never use lists unless explicitly asked."
                    ),
                },
                {
                    "role": "user",
                    "content": question,
                },
            ],
            "temperature": 0.1,
            "search_domain_filter": [
                "-wikipedia.org",
            ],
        }
        headers = {
            "Authorization": f"Bearer {PERPLEXITY_API}",
            "Content-Type": "application/json"
        }
        
        response = requests.post(url, json=payload, headers=headers)
        
        if response.status_code == 200:
            response_data = response.json()
            content = response_data['choices'][0]['message']['content']
            citations = response_data.get('citations', [])
            
            # Format bibliography
            bibliography_dict = {}
            if citations:
                counter = 1
                for citation in citations:
                    bibliography_dict[str(counter)] = [citation]
                    counter += 1
            
            # Extract confidence scores from text
            pattern = r"confidence score:\s*([0-9.]+)(?:\s*\)\s*((?:\[\d+\]\s*)+)|\s+based on\s+(\[\d+\]))"
            matches = re.findall(pattern, content, re.IGNORECASE)
            for score, refs1, refs2 in matches:
                confidence = score
                refs = refs1 if refs1 else refs2
                ref_nums = re.findall(r"\[(\d+)\]", refs)
                for num in ref_nums:
                    if num in bibliography_dict:
                        bibliography_dict[num].append(confidence)
            
            # Format bibliography
            bibliography = ""
            references = "\n\n\n**References:**\n"
            further_reading = "\n**Further Reading:**\n"
            for key, value in bibliography_dict.items():
                if len(value) > 1:
                    references += f"[{key}]: {value[0]} \n      (Confidence: {value[1]})\n"
                else:
                    further_reading += f"[{key}]: {value[0]} \n"
            if references != "\n\n\n**References:**\n":
                bibliography += references
            if further_reading != "\n**Further Reading:**\n":
                bibliography += further_reading
            
            # Clean confidence scores from content
            clean_pattern = r"\(\s*confidence score:\s*[0-9.]+\s*\)"
            content = re.sub(clean_pattern, "", content, flags=re.IGNORECASE)
            content = re.sub(r'\s+', ' ', content)
            
            return {
                "content": content,
                "bibliography": bibliography,
                "confidence_score": 0.8,  # Default confidence for Perplexity
                "processing_time": 0.0,
                "source": "Perplexity",
                "metadata": {"citations_count": len(citations)}
            }
        else:
            raise Exception(f"Perplexity API error: {response.status_code}, {response.text}")
            
    except Exception as e:
        logging.error(f"Perplexity query failed: {str(e)}")
        raise


@cl.on_message
async def on_message(message: cl.Message):
    start = time.time()
    detector: LanguageDetector = cl.user_session.get("detector")
    translator: BaseTranslator = cl.user_session.get("translator")
    lightrag_component: LightRAGComponent = cl.user_session.get("lightrag_component")
    content = message.content

    await cl.Message(
                content = "Thinking...",
                author="CMO",
            ).send()

    language = cl.user_session.get("language")
    if not language or language == "auto":
        detection = await detect_language(detector, content)
        language = detection["language"]
    if language != "en" and language is not None:
        content = await translate(translator, content, source=language, target="en")

    # Try LightRAG first, then fall back to Perplexity
    response_data = None
    error_messages = []
    
    # Attempt LightRAG query
    if lightrag_component is not None:
        try:
            logging.info("Attempting LightRAG query")
            response_data = await query_lightrag(lightrag_component, content)
            logging.info(f"LightRAG query successful with confidence: {response_data.get('confidence_score', 0.0)}")
        except Exception as e:
            error_messages.append(f"LightRAG failed: {str(e)}")
            logging.warning(f"LightRAG query failed, falling back to Perplexity: {str(e)}")
    else:
        error_messages.append("LightRAG component not available")
        logging.info("LightRAG component not available, using Perplexity")
    
    # Fall back to Perplexity if LightRAG failed or unavailable
    if response_data is None:
        try:
            logging.info("Attempting Perplexity query")
            response_data = await query_perplexity(content)
            logging.info("Perplexity query successful")
        except Exception as e:
            error_messages.append(f"Perplexity failed: {str(e)}")
            logging.error(f"Perplexity query also failed: {str(e)}")
    
    # Handle case where both systems failed
    if response_data is None:
        response_content = (
            "I apologize, but I'm currently experiencing technical difficulties. "
            "Both my knowledge base and real-time search capabilities are temporarily unavailable. "
            "Please try again later."
        )
        bibliography = f"\n\n**System Status:**\n" + "\n".join(f"- {msg}" for msg in error_messages)
        processing_time = time.time() - start
    else:
        response_content = response_data["content"]
        bibliography = response_data["bibliography"]
        processing_time = response_data["processing_time"]
        
        # Add source information
        source_info = f"\n\n*Response from: {response_data['source']}*"
        if response_data.get("confidence_score"):
            source_info += f" (Confidence: {response_data['confidence_score']:.2f})"
        response_content += source_info

    # Translate response back to user's language if needed
    if language != "en" and language is not None:
        # Check if this is a LightRAG response and use appropriate translation
        if response_data and is_lightrag_response(response_data):
            try:
                # Use LightRAG-aware translation
                translated_response_data = await translate_lightrag_response(
                    response_data, translator, detector, language, "en"
                )
                response_content = translated_response_data["content"]
                # Update bibliography with translated version
                if translated_response_data.get("bibliography"):
                    bibliography = translated_response_data["bibliography"]
            except Exception as e:
                logging.warning(f"LightRAG translation failed, using fallback: {str(e)}")
                # Fallback to simple translation
                response_content = await translate(translator, response_content, source="en", target=language)
        else:
            # Use regular translation for non-LightRAG responses
            response_content = await translate(translator, response_content, source="en", target=language)

    # Add bibliography and timing information
    if bibliography:
        response_content += bibliography

    end = time.time()
    response_content += f"\n\n*{end - start:.2f} seconds*"
    
    response_message = cl.Message(content=response_content)
    await response_message.send()


@cl.on_settings_update
async def on_settings_update(settings: dict):
    translator = settings["translator"]
    if translator == "Google":
        translator: BaseTranslator = get_translator("google")
    elif translator == "OPUS-MT":
        translator: BaseTranslator = get_translator("opusmt")
    await set_chat_settings(translator)
    cl.user_session.set("translator", translator)
    language = settings["language"]
    if language == "Detect language":
        language = "auto"
    else:
        languages_to_iso_codes = translator.get_supported_languages(as_dict=True)
        language = languages_to_iso_codes.get(language.lower(), "auto")
    cl.user_session.set("language", language)
